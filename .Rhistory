makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # xinv stores the result of the inversion
# "set" function is used to set a matrix to object created by makeCacheMatrix
set <- function(y) {
x <<- y
xinv <<- NULL # initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(solve) xinv <<- solve # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
#x <- makeCacheMatrix(testmatrix)
#x$set(newmatrix) # to change matrix
#x$get # to get the setted matrix
#x$setInv # to set the inversed matrix
#x$getInv # to get the inversed matrix
list(set = set, get = get,
setInv = setInv,
getInv = getInv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getInv() # get the inversed matrix from object x
# it will be null if uncalculated, remember the first line "xinv <- NULL" in the previous function
if(!is.null(m)) { # if the inversion result is there
message("getting cached data")
return(m) # return the calculated inversion
}
data <- x$get() # if not, we do x$get to get the matrix object
m <- solve(data) # we solve it
x$setInv(m) # we then set it to the object
m # return the solved result
}
test <- matrix(runif(9,1,100),3,3)
testCached <- makeCacheMatrix(test)
testInv <- cacheSolve(testCached)
testInv
test
solve(test)
test
?inv
?solve
makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # xinv stores the result of the inversion
# "set" function is used to set a matrix to object created by makeCacheMatrix
set <- function(y) {
x <<- y
xinv <<- NULL # initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(inversed) xinv <<- inversed # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
#x <- makeCacheMatrix(testmatrix)
#x$set(newmatrix) # to change matrix
#x$get # to get the setted matrix
#x$setInv # to set the inversed matrix
#x$getInv # to get the inversed matrix
list(set = set, get = get,
setInv = setInv,
getInv = getInv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getInv() # get the inversed matrix from object x
# it will be null if uncalculated, remember the first line "xinv <- NULL" in the previous function
if(!is.null(m)) { # if the inversion result is there
message("getting cached data")
return(m) # return the calculated inversion
}
data <- x$get() # if not, we do x$get to get the matrix object
m <- solve(data) # we solve it
x$setInv(m) # we then set it to the object
m # return the solved result
}
makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # xinv stores the result of the inversion
# "set" function is used to set a matrix to object created by makeCacheMatrix
set <- function(y) {
x <<- y
xinv <<- NULL # initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(inversed) xinv <<- inversed # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
#x <- makeCacheMatrix(testmatrix)
#x$set(newmatrix) # to change matrix
#x$get # to get the setted matrix
#x$setInv # to set the inversed matrix
#x$getInv # to get the inversed matrix
list(set = set, get = get,
setInv = setInv,
getInv = getInv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getInv() # get the inversed matrix from object x
# it will be null if uncalculated, remember the first line "xinv <- NULL" in the previous function
if(!is.null(m)) { # if the inversion result is there
message("getting cached data")
return(m) # return the calculated inversion
}
data <- x$get() # if not, we do x$get to get the matrix object
m <- solve(data) # we solve it
x$setInv(m) # we then set it to the object
m # return the solved result
}
test <- matrix(runif(9,1,100),3,3)
testCached <- makeCacheMatrix(test)
testInv <- cacheSolve(testCached)
testInv
test
solve(test)
test
test <- matrix(runif(9,1,100),3,3)
test
solve(test)
testCached <- makeCacheMatrix(test)
testInv <- cacheSolve(testCached)
makeCacheMatrix(test)
testInv
solve(test)
matrica<- matrix(runif(9,1,100),3,3)
a <- makeCacheMatrix(matrica)
b <- cacheSolve(a)
b
test
solve(test)
b
matrica
solve(matrica)
matrica<- matrix(c(2, 8, 3, 1, 5, 7,4,6,9), nrow=3, ncol = 3)
a <- makeCacheMatrix(matrica)
b <- cacheSolve(a)
b
matrica
solve(matrica)
## The first function "makeCacheMatrix" creates a special "matrix"
##object that can cache its inverse. Second function "cacheSolve" computes the inverse
##of the special "matrix" returned by "makeCacheMatrix" function.
##If the inverse has already been calculated (and the matrix has not changed),
##then the "cachesolve" should retrieve the inverse from the cache. The rationale behind
##caching the inverse of a matrix is that it is costly to re-compute the matrix de-novo
##each time, and it may be beneficial to retrieve the cached inverse, if the matrix did
##not change.
makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # xinv stores the result of the inversion
# "set" function is used to set a matrix to object created by makeCacheMatrix
set <- function(y) {
x <<- y
xinv <<- NULL # initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(inversed) xinv <<- inversed # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
#x <- makeCacheMatrix(testmatrix)
#x$set(newmatrix) # to change matrix
#x$get # to get the setted matrix
#x$setInv # to set the inversed matrix
#x$getInv # to get the inversed matrix
list(set = set, get = get,
setInv = setInv,
getInv = getInv)
}
## cacheSolve calculates the inverse matrix when this has not been done  previously
cacheSolve <- function(x, ...) {
m <- x$getInv() # get the inversed matrix from object x
# it will be null if uncalculated, remember the first line "xinv <- NULL"
##in the previous function
if(!is.null(m)) { # true when the inversion result is already calulated and stored
message("getting cached data")
return(m) # return the calculated inversion
}
data <- x$get() # if not, we do x$get to get the matrix object
m <- solve(data) # performs the job of invertion (solves the matrix)
x$setInv(m) # we then set it to the object
m # return the result of inversion
}
matrica<- matrix(c(2, 8, 3, 1, 5, 7,4,6,9), nrow=3, ncol = 3)
a <- makeCacheMatrix(matrica)
b <- cacheSolve(a)
b
matrica
solve(matrica)
